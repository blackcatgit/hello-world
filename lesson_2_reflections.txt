1. What happens when you initialize a repository? Why do you need to do it?

When I initialize a repository the current folder starts to be tracked by git
and receives a special folder .git where metadata about commits are stored.
If I don't initialize a repository git wont keep track of it and I cannot
make commits in it.

2. How is the staging area different from the working directory and the 
repository? What value do you think it offers?

Repository is the area where all of my commits are stored, it only contains
stuff that I put in there organized in time by order of commits. Working
directory is the place where I add and edit files while I work on them and
these are saved in a repository only when I make a commit, otherwise they
remain unsaved. A staging area is a kind of a cache where I put edited and
added files before I make a commit so that it can include all of the things
I worked on not only one. That way I do not need to add one file at a time
if the change I made was done on multiple files at once.

3. How can you use the staging area to make sure you have one commit per 
logical change?

It makes that possible by enabling me to add more than one file into a single
commit and commiting all those multiple changes as one change done. Logical
change may then include more than one file and more than one edit but also may
exclude other files eddited if I want to make a second commit for those.

4. What are some situations when branches would be helpful in keeping your 
history organized? How would branches help?

A branch can help if I want to follow some idea but not necessarely apply it
to the master project yet. Later I can merge the new branch with master or just
discard that change and continue master from where it was initially.

5. How do the diagrams help you visualize the branch structure?

Branch diagram helps to keep track of all the branches and their position in
time so that you can see on what level each branch started and how far each
of them go separately in order to make a conscious decision whether to merge
it and with what you want to merge.

6. What is the result of merging two branches together? Why do we represent
it in the diagram the way we do?

No fucking idea

7. What are the pros and cons of Git’s automatic merging vs. always doing
 merges manually?
 
Automatic merging merges things that don't look simmilar so I dont have to
check out both files and assure they are simmilar. Manual mergings is helpful
to determine how to deal with files that both look different and help to create
a summary change that covers both differences in both files.